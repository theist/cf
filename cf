#!/usr/bin/env python3

# This software is based in whole or in part on code generated by an artificial intelligence system

import argparse
import os
import subprocess
import sys
import tempfile
import shlex # For robustly splitting EDITOR variable

try:
    import google.generativeai as genai
except ImportError:
    print("Error: google-generativeai library not found. Please install it: pip install google-generativeai")
    sys.exit(1)

try:
    from rich.console import Console
    from rich.panel import Panel
    from rich.text import Text
    from rich.syntax import Syntax
    from rich.style import Style
    from rich.rule import Rule
except ImportError:
    print("Error: rich library not found. Please install it: pip install rich")
    sys.exit(1)

try:
    import readchar
except ImportError:
    print("Error: readchar library not found. Please install it: pip install readchar")
    sys.exit(1)

# --- Configuration ---
GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY")
EDITOR = os.environ.get("EDITOR", "vim") 
MODEL_NAME = os.environ.get("CF_MODEL_NAME", "gemini-2.5-flash-preview-05-20") # model spec

# --- Console ---
console = Console()

# --- Styles ---
prompt_style = Style(color="cyan")
command_style = Style(color="yellow")
explanation_style = Style(color="green")
error_style = Style(color="red", bold=True)
info_style = Style(color="blue")
warning_style = Style(color="orange1", bold=True)

# --- Gemini Interaction ---
def configure_gemini():
    if not GEMINI_API_KEY:
        console.print("Error: GEMINI_API_KEY environment variable not set.", style=error_style)
        console.print("Please set it and try again: export GEMINI_API_KEY=\"YOUR_API_KEY\"", style=info_style)
        sys.exit(1)
    try:
        genai.configure(api_key=GEMINI_API_KEY)
    except Exception as e:
        console.print(f"Error configuring Gemini: {e}", style=error_style)
        sys.exit(1)

def get_gemini_response(prompt_text: str) -> str | None:
    try:
        model = genai.GenerativeModel(MODEL_NAME)
        # Configure safety settings to be less restrictive for command generation,
        # but be aware of the implications.
        # For this tool, we rely on user discretion before execution.
        safety_settings = [
            {"category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_NONE"},
            {"category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_NONE"},
        ]
        response = model.generate_content(prompt_text, safety_settings=safety_settings)

        if response.parts:
            return response.text.strip()
        elif response.prompt_feedback and response.prompt_feedback.block_reason:
            console.print(f"Gemini request blocked: {response.prompt_feedback.block_reason_message}", style=error_style)
            if response.prompt_feedback.safety_ratings:
                for rating in response.prompt_feedback.safety_ratings:
                    console.print(f"  - Category: {rating.category}, Probability: {rating.probability}", style=error_style)
            return None
        else:
            # Check for empty candidates list or other non-part responses
            if not hasattr(response, 'text') or not response.text:
                 console.print("Gemini returned an empty or unexpected response structure.", style=error_style)
                 return None
            return response.text.strip() # Fallback if parts is empty but text exists
            
    except Exception as e:
        console.print(f"Error communicating with Gemini: {e}", style=error_style)
        return None

def get_linux_command(user_task_description: str) -> str | None:
    prompt = f"""
You are an expert Linux shell assistant. Your sole purpose is to provide a concise, directly executable bash command.
The user wants a command to: {user_task_description}

Follow these strict rules for your response:
1. Provide ONLY the bash command.
2. The command MUST be compatible with bash.
3. The command should preferably be a one-liner.
4. The command must NOT exceed four lines.
5. Do NOT include any surrounding markdown (like ```bash ... ``` or ``` ... ```).
6. Do NOT include any comments (lines starting with #).
7. Do NOT include any explanations, apologies, or conversational text.
8. Ensure the command is directly executable in a standard bash shell.
9. If the request is ambiguous or cannot be fulfilled with a safe command, respond with the exact text: Error: Cannot generate command for this request.
    """.strip()
    
    command = get_gemini_response(prompt)
    if command and "Error: Cannot generate command" in command:
        console.print(command, style=error_style)
        return None
    if command:
        # Clean up potential markdown backticks if Gemini doesn't follow instructions perfectly
        if command.startswith("```bash"):
            command = command[len("```bash"):]
        elif command.startswith("```"):
            command = command[len("```"):]
        if command.endswith("```"):
            command = command[:-len("```")]
        
        command = command.strip()
        if not command: # Explicitly check for empty string after stripping
            return None
        return command
    return None

def get_command_explanation(command: str) -> str | None:
    prompt = f"""
You are an expert Linux shell assistant. Your sole purpose is to explain a given bash command.
Explain the following Linux bash command clearly and concisely:

Command:
{command}

Provide only the explanation. Do not add any conversational fluff or introductory/concluding remarks.
Focus on what each part of the command does and its overall purpose. Explain the purpose before
going into details. Do not use markdown aws the output is meant to be shown as text. You should not
describe pipes or redirects as independent items.
    """.strip()
    return get_gemini_response(prompt)

# --- Command Execution and Editing ---
def execute_command_in_shell(command_str: str):
    console.print(f"\nExecuting: [bold yellow]{command_str}[/bold yellow]", style=info_style)
    console.print(Rule(style=info_style))
    try:
        process = subprocess.Popen(
            command_str, 
            shell=True, 
            stdout=subprocess.PIPE, 
            stderr=subprocess.PIPE, 
            text=True, 
            bufsize=1, # Line-buffered
            universal_newlines=True # Same as text=True, ensures text mode
        )
        
        if process.stdout:
            for line in process.stdout:
                sys.stdout.write(line)
                sys.stdout.flush()
        
        if process.stderr:
            for line in process.stderr:
                sys.stderr.write(line)
                sys.stderr.flush()

        process.wait() # Wait for the command to complete
        console.print(Rule(style=info_style))
        if process.returncode == 0:
            console.print("Command executed successfully.", style=explanation_style)
        else:
            console.print(f"Command exited with error code {process.returncode}.", style=error_style)

    except Exception as e:
        console.print(f"Failed to execute command: {e}", style=error_style)

def edit_command_in_editor(command_str: str) -> str | None:
    try:
        with tempfile.NamedTemporaryFile(mode='w+', delete=False, suffix='.sh', prefix='cf_edit_') as tmp_file:
            tmp_file.write(command_str)
            tmp_file_path = tmp_file.name
        
        editor_parts = shlex.split(EDITOR)
        cmd_to_run = editor_parts + [tmp_file_path]

        # Temporarily suspend Rich console to allow editor to take over cleanly
        with console.screen() as screen:
             # This context manager might not be what we need for subprocess.
             # Simpler: just run the subprocess. Rich usually handles this okay.
             pass # No specific screen handling needed here, Rich is generally fine.

        process = subprocess.run(cmd_to_run) # Let editor run in the current terminal

        with open(tmp_file_path, 'r') as tmp_file:
            edited_command = tmp_file.read().strip()
        
        os.unlink(tmp_file_path)

        if edited_command != command_str:
            console.print("Command edited.", style=info_style)
        return edited_command
    except FileNotFoundError:
        console.print(f"Error: Editor '{EDITOR}' not found. Please check your $EDITOR environment variable.", style=error_style)
        return command_str # Return original command if editor not found
    except Exception as e:
        console.print(f"Error during editing: {e}", style=error_style)
        return command_str # Return original command on other errors

# --- Main Logic ---
def main():
    parser = argparse.ArgumentParser(
        description="AI-powered command finder (cf). Gets a Linux command from Gemini based on your prompt.",
        epilog="Example: cf 'list all python files modified in the last 24 hours'"
    )
    parser.add_argument("user_prompt_parts", nargs="+", metavar="PROMPT",
                        help="The prompt describing the desired Linux command.")
    args = parser.parse_args()

    user_prompt = " ".join(args.user_prompt_parts)

    configure_gemini()
    
    console.clear()
    console.print(Rule(f"[bold {prompt_style.color.name}]Command Finder[/bold {prompt_style.color.name}] - Querying Gemini..."))
    console.print(f"Your prompt: \"{user_prompt}\"", style=prompt_style)
    
    current_command = get_linux_command(user_prompt)

    if not current_command:
        console.print("Could not retrieve a command for your prompt.", style=error_style)
        sys.exit(1)

    while True: 
        console.print(Rule("[bold blue]Suggested Command[/bold blue]"))
        
        syntax = Syntax(current_command, "bash", theme="monokai", line_numbers=False, word_wrap=True)
        console.print(syntax)
        
        console.print("\nFetching explanation...", style=info_style)
        explanation = get_command_explanation(current_command)
        
        if explanation:
            explanation_panel = Panel(
                Text(explanation, style=explanation_style),
                title="[bold green]Explanation[/bold green]",
                border_style="green",
                expand=False
            )
            console.print(explanation_panel)
        else:
            console.print("Could not retrieve explanation for the command.", style=error_style)

        console.print(Rule(style=info_style))
        console.print(Text.assemble(
            ("Actions: ", "bold"),
            ("<Enter>", "bold green"), " Run  ",
            ("E", "bold yellow"), " Edit  ",
            ("P", "bold cyan"), " Print  ",
            ("<Esc>", "bold red"), " Cancel"
        ))
        console.print(Panel(
            Text("Executing AI-generated commands can be risky. Review carefully before running!", style=warning_style),
            title="[bold red]WARNING[/bold red]",
            border_style="red",
            expand=False
        ))
        console.print("Your choice: ", end="", style=prompt_style) # Prompt for input

        try:
            choice = readchar.readkey()
        except Exception as e:
            console.print(f"\nError reading input: {e}. Is this a TTY?", style=error_style)
            console.print("Defaulting to cancel.", style=info_style)
            choice = readchar.key.ESC

        console.print() # Newline after choice input

        if choice == readchar.key.ENTER:
            execute_command_in_shell(current_command)
            break 
        elif choice.lower() == 'e':
            console.print("Opening command in editor...", style=info_style)
            edited_command = edit_command_in_editor(current_command)
            console.clear()
            if edited_command is not None and edited_command != current_command:
                current_command = edited_command
                console.print(Rule("[bold blue]Command Updated[/bold blue]"))
            elif edited_command is None: 
                console.print("Editor failed or returned no content. Keeping original command.", style=error_style)
            else: # No changes or editor aborted
                 console.print(Rule("[bold blue]Edit Cancelled / No Changes[/bold blue]"))
            continue 
        elif choice.lower() == 'p':
            console.clear()
            console.print(Rule("[bold cyan]Command to Copy[/bold cyan]"))
            console.print(current_command)
            console.print(Rule(style="cyan"))
            console.print("Press any key to return to options...", style=info_style)
            readchar.readkey()
            console.clear()
            continue
        elif choice == readchar.key.ESC:
            console.print("Cancelled by user.", style=info_style)
            break
        else:
            console.clear()
            console.print(f"Invalid choice: '{choice}'. Please use Enter, e, p, or Esc.", style=error_style)

if __name__ == "__main__":
    main()
